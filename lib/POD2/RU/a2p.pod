=encoding utf8

=head1 НАИМЕНОВАНИЕ

a2p - преобразование кода Awk в Perl

=head1 СИНТАКСИС

B<a2p> [I<опции>] [I<имя файла>]

=head1 ОПИСАНИЕ

I<A2p> принимает AWK скрипт, указанный в командной строке (или со стандартного ввода) и производит сравнимый I<perl> скрипт на стандартный вывод.

=head2 Параметры

Параметры включают в себя:

=over 5

=item B<-DE<lt>numberE<gt>>

устанавливает флаги отладки.

=item B<-FE<lt>characterE<gt>>

говорит a2p что бы этот сценарий AWK всегда вызывается с этой B<-F>
опцией.

=item B<-nE<lt>fieldlistE<gt>>

указывает имена полей ввода, если ввод не должен быть разделен на массив.  Если вы переводите сценарий AWK, который обрабатывает файл пароля, вы можете сказать:

	a2p -7 -nlogin.password.uid.gid.gcos.shell.home

Любой разделитель может быть использован для отделения имен полей.

=item B<-E<lt>numberE<gt>>

вызов a2p предполагает, что входящие данные будут всегда содержать много полей.

=item B<-o>

вызовите a2p для использования старого поведения awk.  Только текущей отличия:

=over 5

=item *

Старый AWK всегда выполняет цикл по строкам, даже если нет никаких действий, в то время как новый AWK нет.

=item *

В старых awk sprintf является очень жадным в своих аргументах.
Например, возьмем выражение

	print sprintf(some_args), extra_args;

Старый awk считает I<extra_args> будут аргументы C<sprintf>; новый awk считает их аргументами C<print>.

=back

=back

=head2 "Соображения"

A2p  не может делать работу по переводу так же хорошо, как человек, но он обычно делает  свою работу довольно хорошо.  Есть некоторые области, где вы можете изучать perl-скрипт, который создает программа и донастроить его при необходимости.  Вот некоторые из них, без особого порядка.

Существует идиома awk ставить int()  вокруг строкового выражения, чтобы сделать преобразование к числу, хотя аргумент всегда целое так или иначе.  Это, как правило, не нужно в Perl, но a2p не может сказать, если аргумент всегда будет целое, то он оставляет его целым.  Вы можете удалить его.

Perl отличает числовое сравнение от сравнения строк.  Awk
 имеет один оператор для обеих операций, который решает что делать во время выполнения.  A2p не пытается сделать полную работу по эмуляции AWK в этой точке.  Вместо этого он предлагает то, что вы хотите.  Это почти всегда верно, но иногда можно впасть в обман (это может быть подделано).  Все эти домыслы, помечены комментарием "C<#???>".  Вы должны пройти через них и проверить.  Возможно, вы захотите запустить по крайней мере один раз с B<-w> опцией to perl, которая предупредит вас если вы используете == где вы должны были использовать eq.

Perl не пытается эмулировать поведение AWK, в котором несуществующие элементы массива начинают существовать просто по созданию на них ссылки.  Если каким-то образом вы полагаетесь на этот механизм для создания пустых записей для последующего для ..., их там не будет в Perl.

Если a2p делает разбор строки, которая представляет собой список переменных, который выглядит как (Fld1, Fld2, Fld3...) вы можете повторно запустить a2p используя опцию
B<-n> , упомянутую выше.  Это позволит вам переименовывать поля во всем сценарии.  Вместо этого он разбивает на массив, вероятно, ссылаясь на число полей где-нибудь.

Для выхода из программы не обязательно ставить оператор EXIT, в AWK программа идет до конца блока, если он есть.  Awk сценарии, которые делают искажения до END блока в обход блока при таких обстоятельствах может быть упрощена путем удаления условия в блоке END и просто выходом непосредственно из perl скрипта.

Perl имеет два вида массивов, численно-индексированных и ассоциативные.
Perl ассоциативные массивы называются "хэшами".  Awk массивы, как правило, переводятся в хэши, но если вы ожидаете, что индекс всегда собирается быть числовыми вы могли бы изменить {...}, в [...].
Перебор хэша может быть с помощью комбинации функции keys(), но это не подходит для перебора массива.  Возможно, вам придется изменить цикл, который перебирает такой массив.

Awk начинает, предполагая OFMT имеет значение %.6g.  Perl начинается, предполагая, что его эквивалент, $# должен иметь значение %.20g.  Вам придется установить $# явно, если вы используете значение по умолчанию OFMT.

В верхней части линии цикла будет операция разбиения по частям (split), которая подразумевается в сценарий AWK.  Есть моменты, когда вы можете двигаться вниз после некоторых условий, которые проверяют всю запись так, что разбиения не будет сделано, как обычно.

По эстетическим соображениям вы можете пожелать изменить индексных переменных от того, начинается с 1 (AWK стилю) до 0 на основе (Perl стиль).  Будьте тогда намерены изменить все операционные переменные, которые участвуют в поиске.

Симпатичные комментарии, которые выглядят как "# Это обходной путь, потому что AWK является немым" и пропускает их без изменений.

Awk скрипты часто встроены в шелл скрипты, которые участвую в конвейере (pipe) на входе и выходе из AWK.  Часто обертка скрипта может быть включена в сценарий Perl, так как Perl может начаться до конвейера (pipe - "|" ) в и из себя, и делать другие вещи, которые AWK не может сделать сам по себе.

Сценарии, которые относятся к специальным переменным RSTART и RLENGTH часто могут быть упрощены путем ссылки на переменные $ `, $ & и $ ', пока они находятся в пределах поиска по шаблону, который устанавливает их.

Полученный Perl скрипт может иметь подпрограммы, которые определены иметь дело с семантикой AWK относительно getline и print.  С a2p обычно выбирает правильности над эффективностью.  почти всегда можно переписать такой код, чтобы быть более эффективным путем отбрасывания семантического сахара.

Для эффективности, вы можете удалить ключевое слово из любого возвращенного выражения, что является последним оператором выполненным в подпрограмме.  А2р ловит самый распространенный случай, но не анализирует встроенные блоки для тонких случаях.

ARGV[0] переводит к $ARGV0, но ARGV[N] переводит к $ARGV [$n-1].  Цикл, который пытается перебрать ARGV[0] не найдет его.

=head1 ОКРУЖЕНИЕ

А2р не использует переменные окружения.

=head1 АВТОР

Лари Волл E<lt>F<larry@wall.org>E<gt>

=head1 ФАЙЛЫ

=head2 СМОТРИТЕ ТАКЖЕ

 perl	The perl компилятор/интерпретатор

 s2p	перевод sed в perl

=head1 ДИАГНОСТИКА

=head2 ОШИБКИ

Можно было бы подражать поведению AWK в выборе строки сравнении числовых операций во время выполнения проверки операнда, но это было бы грубым и неэффективным.  Кроме того, A2P почти всегда угадывает правильно.

Память для синтаксического дерева AWK в настоящее время является статической, и может не хватить.

=head1 ПЕРЕВОДЧИКИ

=over

=item * Николай Мишин  C<< <mishin@cpan.org> >>

=back
